---
layout: post
title:  "TIL(20240521) Spring:인증과 인가 "
date:  2024-05-21
categories: TIL Spring 코딩테스트
---


---------------------------------------------------------------------

# 📌 Spring

## 💡 인증과 인가

- 인증(Authentication)
1) 인증은 해당 유저가 실제 유저인지 인증하는 개념
2) 실제 유저가 맞는지 확인하는 절차
- 인가(Authorization)
1) 인가는 해당 유저가 특정 리소스에 접근이 가능한지 허가를 확인하는 개념
ex) 회원인지? 비회원인지? 유저-마이페이지, 관리자페이지- 관리자권한

## 💡 인증 방식

1) 쿠키-세션 방식의 인증
- 쿠키-세션 방식은 서버가 '특정 유저가 로그인 되었다'는 상태를 저장하는 방식이다.
인증과 관련된 아주 약간의 정보만 서버가 가지고 있게 되고 유저의 이전상태의 전부는 아니더라도
인증과 관련된 최소한 정보는 저장해서 로그인을 유지시킨다는 개념이다.
- JWT와 차이점: 세션저장소 세션생성 후 쿠키검증
2) JWT기반 인증
- JWT(JSON Web Token)란 인증에 필요한 정보를 암호화시킨 토큰을 의미한다. JWT인증은 쿠키/세션과 유사하게 JWT토큰을 HTTP헤더에 실어 서버가 클라이언트를 식별한다.
- 쿠키-세션 방식과 차이점: DB에서 회원확인 후 ACCESS 토근 발급해 바로 검증

## 💡 웹 어플리케이션에서는 인증을 어떻게 처리하는가?

1) 클라이언트-서버 구조 -> HTTP 프로토콜로 통신(비연결성 무상태) -> 서버와 클라이언트는 실제로 연결되어있지 않음 -> 즉, 클라이언트의 상태를 저장하고 있지 않다. 
2) 왜 실제로 연결이 되어있지 않는가? 계속 연결이 되어있다면 서버 과부하 상태가 될 수 있음(서버비용 부담을 증가시킨다.)
3) 그렇다면 비연결성 무상태에서는 어떻게 유저의 인증을 처리할 수 있는가? 어떻게 처리할 것인가? 아래 쿠키와 세션에서 자세히 살펴보자

## 💡 쿠키-세션의 인증

- 쿠키와 세션 모두 HTTP에 상태 정보를 유지하기 위해 사용된다. 즉, 쿠키와 세션을 통해 서버에서는 클라이언트별로 인증 및 인가를 할 수 있게 된다.
- 최소한의 정보만 가지고 인증한다. 
- 과정: 사용자 로그인-> 서버-> 사용자 확인 (회원DB에서) -> 서버-> 회원정보 세션 생성 (세션 저장소에서)-> sessionID 발급 -> 서버->
응답-> 사용자-> 데이터요청(+쿠키) -> 쿠키검증 (세션저장소에서)-> 유저정보(세션) 획득-> 응답(+요청데이터)  

## 💡 쿠키? 세션?
1. 쿠키 : 토큰 저장소, 저장공간이다. 클라이언트에 저장될 목적으로 생성한 작은 정보를 담은 파일
2. 세션(식별자값)  : 인증 정보
1) 서버에서 일정시간 동안 클라이언트 상태를 유지하기 위해 사용됨
2) 서버에서 클라이언트별로 유일무이한 '세션ID'를 부여한 후 클라이언트별 필요한 정보를 서버에 저장함
3) 서버에서 생성한 '세션ID'는 클라이언트의 쿠키값('세션쿠키'라고 부름)으로 저장되어 클라이언트 식별에 사용됨

## 💡 JWT 기반의 인증

- 인증과정 : 사용자 로그인-> 서버-> 사용자 확인(회원DB에서) -> 서버 -> 암호화된 Access Token(JWT)발급 -> 서버 -> 응답(+Access Token) -> 사용자 -> 데이터요청(+JWT) -> 서버-> Access Token 검증 -> 응답(+요청데이터) 

## 💡 쿠키-세션방식과 JWT기반의 인증의 차이점은?

- 쿠키-세션방식은 세션저장소가 따로 있다.
- JWT는 토큰 자체를 서버에 던지고 그 서버를 검증만 한다. (서버과부하가 줄어듬)



---------------------------------------------------------------------

# 📌 코딩테스트 : 나누어 떨어지는 숫자 배열

## 🔒 문제 : array의 각 element 중 divisor로 나누어 떨어지는 값을 오름차순으로 정렬한 배열을 반환하는 함수, solution을 작성해주세요. divisor로 나누어 떨어지는 element가 하나도 없다면 배열에 -1을 담아 반환하세요.

## 🚫 조건 : 
- arr은 자연수를 담은 배열입니다.
- 정수 i, j에 대해 i ≠ j 이면 arr[i] ≠ arr[j] 입니다.
- divisor는 자연수입니다.
- array는 길이 1 이상인 배열입니다.

# 💡 필요했던 메서드
- Arrays.sort() : 오름차순 정렬


# 🔓 문제풀이
```java

import java.util.Arrays;
import java.util.ArrayList;

class Solution {
    public int[] solution(int[] arr, int divisor) {
        int[] answer = {};
        
        ArrayList<Integer> list = new ArrayList<Integer>();
        
        for(int i=0; i<arr.length; i++){
            if(arr[i]%divisor == 0) {
                list.add(arr[i]);
            } 
            if (list.size() == 0){
                answer = new int[]{-1};
            } else {
                answer = new int[list.size()];
                for (int j=0; j<list.size(); j++){
                    answer[j] = list.get(j);
                }
                Arrays.sort(answer);
            }
            
        }
        return answer;
    }
}

```

## 🤷‍♀️ 코딩테스트 1 문제풀이를 하면서 느낀점
: 처음 생각한건 int[] answer 배열은 변경 불가능하기에 값을 필터링한 후 값을 넣어줄 수 있는 임시 저장소가 필요하다고 생각했다.    
그래서 생각한 건 ArrayList(변경가능한 객체)를 생성하여 임시로 answer의 값들을 list(참조변수)에 넣어두고 다시 answer배열에 옮겨야 겠다는 생각이 들었다.
배열과 컬렉션에서는 배열의 길이 length/ 배열의 크기 size가 다르니 주의하자. 


## 🎈 코딩테스트 1 다른사람의 풀이! 
- 다른사람의 풀이를 보니 stream으로 문제를 풀었던 것 같다. 아직 나는 stream이 뭔지 제대로 알지도 못하니 공부를 하고 참고하자 생각해서
이번에는 다른사람의 풀이를 보지 않았다. 


--------------------------------------------------------------
