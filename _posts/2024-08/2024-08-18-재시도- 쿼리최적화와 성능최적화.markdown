---
layout: post
title:  "TIL(20240818) [재시도- 쿼리최적화와 성능최적화]"
date:  2024-08-18
categories: TIL 
---

----------------------------------------------------------------------------

내가 이때까지 인덱스 공부를 잘못했었나보다.

인덱스가 적용이 안되었는데, 인덱스 적용이 되었다고 생각하고 EXPLAIN 명령어로 인덱스적용이 되었는지 보면 ALL로 뜨면서 계속에서 테이블 풀스캔을 하고 있다는 응답을 받고 있었지.

그래서 뭔가 이상해서 계속 찾아보고 찾아보니 내가 인덱스적용을 똑바로 하지 않았다. 그러니까 인덱스 적용을 하지 않고 인덱스 적용이 되었다고 생각하고 테스트를 해본 격..😅 멍충..?

```
**EXPLAIN 명령어 사용: EXPLAIN 명령어를 사용하여 쿼리가 인덱스를 사용하는지 확인
ex) EXPLAIN SELECT * FROM user ORDER BY point DESC LIMIT 10;
```

그래서 다시 인덱스로 포인트 랭킹조회를 쿼리최적화를 다시 시도해보려고 한다.


1. 인덱스 추가

```
CREATE INDEX idx_point_desc ON db_users(point DESC);
```

SQL 콘솔에서 user 테이블의 point 필드에 내림차순 인덱스를 생성한다. 이렇게 설정을 해두면 ORDER BY point DESC 쿼리 성능이 크게 향상된다.

그 다음 

2. SHOW INDEX FROM db_users; 명령어를 사용하여 point 필드에 대한 인덱스가 실제로 존재하는지 확인
- SHOW INDEX 결과를 보면 idx_point_desc 인덱스가 제대로 생성된 것을 확인

![image](https://github.com/user-attachments/assets/c02cbcd9-d095-47fa-97d0-31755d3091e7)


3. SELECT * FROM db_users ORDER BY point DESC LIMIT 10; 쿼리 실행해보기 (해당 쿼리가 잘 실행되는지 확인)

![image](https://github.com/user-attachments/assets/93564291-6eff-40d2-8a4f-39fe9d006cef)

4. EXPLAIN SELECT * FROM db_users ORDER BY point DESC LIMIT 10; 쿼리가 인덱스를 잘 사용해서 데이터를 불러오고 있는지 확인

![image](https://github.com/user-attachments/assets/c6a4bec6-ae96-496d-a3e1-663da8a73388)

- EXPLAIN 결과에서 ALL과 Using filesort가 나타난다면 인덱스가 최적화에 적합하지 않다는 의미
- type에 ALL을 나타내는 것은 인덱스를 사용하지 않고 전체 테이블 스캔을 선택했다는 것을 의미

5. 혹시나 데이터베이스의 통계가 오래되어서? 그런가.. 업데이트를 했으나
![image](https://github.com/user-attachments/assets/06c726c7-d14d-4516-bca6-a0a2b7c87db9)

결과적으로 인덱스를 사용해서 쿼리최적화는 적합하지 않다고 판단했는데 그 이유는 

1. 인덱스의 잦은 업데이트 : point 컬럼은 우리 프로젝트의 특성상 자주 업데이트 되기에 인덱스의 유지 비용이 증가하기에 성능에 부정적인 영향을 줄 것으로 예상(데이터가 변경될때마다 인덱스도 업데이트 되어야 함)
- 인덱스는 주로 읽기 작업에서 성능을 향상시키는데 잦은 쓰기,업데이트의 경우 오히려 성능저하를 발생시킬 수 있음(인덱스를 업데이트할 때의 추가적인 오버헤드)

2. 데이터 분포 불균형: 특정 point 값에 많은 데이터가 집중되어 있을 때, 인덱스를 사용하여 정렬하는 것은 비효율적일 수 있음

3. explain 결과로 `ALL`과 `Using filesort`가 나타난 경우 
 MySQL의 쿼리 옵티마이저가 인덱스를 사용할 때와 전체 테이블 스캔을 선택할 때가 있는데, 여기서 옵티마이저가 인덱스를 사용하는 것이 전체 테이블 스캔보다 더 비효율적이라고 판단했기에 저런 결과를 주지 않았을까 추측함

```
** 쿼리 옵티마이저는 쿼리 성능을 최적화하기 위해 다양한 실행 계획을 분석하고 선택하는 중요한 역할을 한다. 

예를 들어 

SELECT * FROM users WHERE age > 30 ORDER BY name;

했을때 쿼리 옵티마이저는 

- 인덱스 사용: age 컬럼에 인덱스가 있다면 이를 사용할지 여부를 결정
- 정렬 방법: name 컬럼으로 정렬할 때 사용할 정렬 방법을 결정
- 테이블 조인: 여러 테이블을 조인하는 경우, 조인의 순서와 방법을 결정
```

그래서 인덱스로 쿼리최적화 방법은 여기까지 진행하기로 했다.

```
// behind
인덱스 추가했던 것 삭제해주기 

DROP INDEX idx_point_desc ON db_users; // 삭제
SHOW INDEX FROM db_users; // 삭제 되었는지 확인
```



