---
layout: post
title:  "TIL(20240617) [(Service) Integration Test]"
date:  2024-06-17
categories: TIL Spring 코딩테스트
---

---------------------------------------------------------------------


## ⭐ what I have to do
- 이론반 수업내용 정리
- 심화주차 강의내용 정리
- 과제 테스트코드 정리
- 지난 프로젝트 notion 정리


---------------------------------------------------------------------


# 📌 Spring

## 💡 Service 통합테스트 




### 🚩 통합테스트와 단위테스트의 차이점
- 통합테스트는 모듈을 통합하는 과정에서 모듈간의 호환성을 확인하기 위한 테스트이며, 단위테스트는 하나의 모듈(하나의 기능)을 독립적으로 진행하여 확인하는 테스트 이다. (모듈: 애플리케이션에서 작동하는 기능 또는 메서드를 의미함)

### 🚩 통합테스트와 단위테스트의 장/단점

단위테스트와 통합테스트 코드를 작성하면서 개인적인
견해가 담긴 장/단점 입니다. 

- 단위테스트의 장점: 테스트 시간 절감/ 자신이 작성한 코드에 대한 확인검증 가능/ 리팩토링 시 코드의 안정성 향상/ 개별적인 코드 단위라 테스트시 디버깅과 문제해결이 쉬움
단위테스트의 단점: 가짜객체(Mock)를 사용하기 때문에 실제 운영환경에서 제대로 동작할 수 있을지 의문이 생김.
통합테스트 장점: springbootContainer을 직접띄워서 테스트하기 때문에 운영환경과 가장 유사한 테스트를 할 수 있다.
통합테스트 단점:  장점으로 인해서 모든 Bean을 로드하기 때문에 시간이 오래걸리고 단위테스트에 비해 무거움, 테스트 단위가 크기때문에 어디서 문제가 발생했는지 찾기가 어려움

### 💡 레이어별로 나누어서 Slice Test 를 하는 이유는?

개인적인 견해가 담긴 이유입니다.

- 코드의 안정성을 확보할 수 있고, 개발자에게 리팩토링 할 수 있는 계기(이전보다 더 나은 코드를 만들게 함)를 만들어주어 단위테스트 코드를 작성하는 것이 아닌가 생각합니다. 

### 💡 테스트 코드를 직접 짜보고 나서 느낀 테스트 필요성
- 장단점에서 작성했던 것 처럼 단위테스트의 경우에는 "이게 실제환경에서 작동할까..?"라는 의문이 가장 많이 들었고, Service단위테스트를 작성한 후 통합테스트를 작성하니 단위,통합테스트는 꼭 필요한 테스트코드 작성이라고 생각했다. 그리고 무엇보다 테스트코드를 작성하면서 핵심기능들의 코드에 대해서 유심히 살펴보고 리팩토링을 하는 부분들이 생겼기에 이전보다 코드가 더 깔끔해졌다라는 걸 느낄 수 있었다. 그리고 어플리케이션의 전체적인 흐름을 깊이 알 수 있는 계기가 되어 너무 좋았다.

<br>



---------------------------------------------------------------------


# 📌 코딩테스트1️⃣ : 이상한 문자 만들기

### 🔒 문제 : 문자열 s는 한 개 이상의 단어로 구성되어 있습니다. 각 단어는 하나 이상의 공백문자로 구분되어 있습니다. 각 단어의 짝수번째 알파벳은 대문자로, 홀수번째 알파벳은 소문자로 바꾼 문자열을 리턴하는 함수, solution을 완성하세요.

### 🚫 조건 : 문자열 전체의 짝/홀수 인덱스가 아니라, 단어(공백을 기준)별로 짝/홀수 인덱스를 판단해야합니다.첫 번째 글자는 0번째 인덱스로 보아 짝수번째 알파벳으로 처리해야 합니다.

## 🔓 문제풀이

```java

class Solution {
    public String solution(String s) {
        String answer = "";
        String[] sArr = s.split(""); // 문자열 잘라서 배열에 넣기
        int index = 0; // 문자배열의 인덱스번호 

        for(int i=0; i<sArr.length; i++){
            if(sArr[i].equals(" ")){  
                index = 0;
            } else if(index % 2 == 0){ // 짝수 - 대문자
                sArr[i] = sArr[i].toUpperCase();
                index++;    
            } else if(index % 2 != 0){ // 홀수 - 소문자
                sArr[i] = sArr[i].toLowerCase();
                index++;
            } answer += sArr[i]; 
        } return answer;
    }
}

```

class Solution {
    public String solution(String s) {
        String answer = "";
        String[] sArr = s.split("");
        int index = 0;
        
        for (int i=0; i<sArr.length; i++){
            if(sArr[i].equals(" ")){
                index=0;
            } else if(index % 2 == 0){
                sArr[i] = sArr[i].toUpperCase();
                index++;
            } else if (index % 2 != 0) {
                sArr[i] = sArr[i].toLowerCase();
                index++;
            } answer += sArr[i];
        } return answer;
    }
}

