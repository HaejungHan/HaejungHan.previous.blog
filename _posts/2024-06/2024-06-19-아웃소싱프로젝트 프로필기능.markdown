---
layout: post
title:  "TIL(20240619) [ì•„ì›ƒì†Œì‹±í”„ë¡œì íŠ¸: í”„ë¡œí•„ê¸°ëŠ¥(ë¹„ë°€ë²ˆí˜¸ë³€ê²½)]"
date:  2024-06-19
categories: TIL Spring
---

---------------------------------------------------------------------

# ğŸ“Œ Spring

## ğŸ’¡ ì•„ì›ƒì†Œì‹±í”„ë¡œì íŠ¸ : í”„ë¡œí•„ ê¸°ëŠ¥(ë¹„ë°€ë²ˆí˜¸ ë³€ê²½)

ì´ì „ì— êµ¬í˜„í–ˆë˜ ë¶€ë¶„ì´ë¼ ë¹„ë°€ë²ˆí˜¸ ë³€ê²½ ë¶€ë¶„ë§Œ ìˆ˜ì •ì¡°ê±´ì´ ì¶”ê°€ë˜ì–´ì„œ ë§ë¶™ì—¬ êµ¬í˜„í•´ë³´ì•˜ë‹¤. 

- **í”„ë¡œí•„ ê´€ë¦¬**
    - ë¹„ë°€ë²ˆí˜¸ ìˆ˜ì • ì¡°ê±´
        - ë¹„ë°€ë²ˆí˜¸ ìˆ˜ì • ì‹œ, ë³¸ì¸ í™•ì¸ì„ ìœ„í•´ í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•˜ì—¬ ì˜¬ë°”ë¥¸ ê²½ìš°ì—ë§Œ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        - ë¹„ë°€ë²ˆí˜¸ëŠ” í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ ë° ìµœê·¼ ì‚¬ìš©í•œ ì„¸ ê°œì˜ ë¹„ë°€ë²ˆí˜¸ì™€ ë‹¤ë¥´ê²Œ ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤.
        - ì˜ˆì‹œ) í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ê°€ 'currentPass'ì´ê³  ì´ì „ ë¹„ë°€ë²ˆí˜¸ê°€ 'password1', 'password2', 'password3'ì˜€ë‹¤ë©´ ìƒˆë¡œìš´ ë¹„ë°€ë²ˆí˜¸ëŠ” ì´ ë„¤ ê°œì™€ ë‹¤ë¥¸ ìƒˆë¡œìš´ ë¹„ë°€ë²ˆí˜¸ì—¬ì•¼ í•©ë‹ˆë‹¤.
    - í”„ë¡œí•„ ìˆ˜ì • ê¸°ëŠ¥
        - ì´ë¦„, í•œ ì¤„ ì†Œê°œì™€ ê°™ì€ ê¸°ë³¸ì ì¸ ì •ë³´ë¥¼ ë³¼ ìˆ˜ ìˆì–´ì•¼ í•˜ë©° ìˆ˜ì •í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤.

```java

@Service
@RequiredArgsConstructor
public class UserService {

  private final UserRepository userRepository;
  private final PasswordEncoder passwordEncoder;
  private final PasswordHistoryRepository passwordHistoryRepository;

  // ì‚¬ìš©ì í”„ë¡œí•„ ì¡°íšŒ
  public UserResponseDto getUser(Long userSeq) {
    User user = findByUserSeq(userSeq);
    return new UserResponseDto(user);
  }

  // ì‚¬ìš©ì í”„ë¡œí•„ ìˆ˜ì •
  @Transactional
  public UserResponseDto updateUser(UserRequestDto requestDto, Long userSeq) {
    User user = findByUserSeq(userSeq);
    user.updateUser(requestDto);
    return new UserResponseDto(user);
  }

  // ë¹„ë°€ë²ˆí˜¸ ë³€ê²½
  @Transactional
  public void updatePassword(UserPwRequestDto requestDto, Long userSeq) {
    User user = findByUserSeq(userSeq);
    String password = requestDto.getPassword();
    String newPassword = requestDto.getNewPassword();

    if (!passwordEncoder.matches(password, user.getUserPassword())) {
      throw new CustomException(ErrorCode.CURRENT_PASSWORD_MATCH);
    }

    if (passwordEncoder.matches(newPassword, user.getUserPassword())) {
      throw new CustomException(ErrorCode.SAME_NEW_PASSWORD);
    }

    List<PasswordHistory> usedPasswords = passwordHistoryRepository.findTop3ByUserOrderByChangedAtDesc(
        user);
    for (PasswordHistory usedPassword : usedPasswords) {
      if (passwordEncoder.matches(newPassword, usedPassword.getPassword())) {
        throw new CustomException(ErrorCode.RECENT_PASSWORD_MATCH);
      }
    }

    if (usedPasswords.size() >= 3) {
      PasswordHistory oldPassword = usedPasswords.get(usedPasswords.size() - 1);
      passwordHistoryRepository.delete(oldPassword);
    }

    PasswordHistory newPasswordHistory = new PasswordHistory(user, passwordEncoder.encode(newPassword), LocalDateTime.now());
    passwordHistoryRepository.save(newPasswordHistory);

    user.updatePassword(passwordEncoder.encode(newPassword));

  }

  private User findByUserSeq(Long userSeq) {
    return userRepository.findById(userSeq).orElseThrow(() ->
        new CustomException(ErrorCode.USER_NOT_FOUND)
    );
  }
}

```
